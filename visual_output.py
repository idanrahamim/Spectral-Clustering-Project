"""This module contains functions for visual output of the data generated by clustering algorithms"""
import matplotlib.pyplot as plt
import matplotlib.colors as clr

# Constants
PLOT_PATH = "clusters.pdf"
# Points color scheme
CMAP = "gist_ncar"
POINT_SIZE = 15


def compute_jaccard_measure(initial_clusters, clusters, n):
    """
    Computes and returns Jaccard measure based on numpy array initial_clusters of original clusters and numpy
    array clusters of new cluster partition generated by of clustering methods

    :param initial_clusters (numpy.ndarray) array of initial clusters generated
    :param clusters (numpy.ndarray) clusters generated by one of the algorithms
    :param n (int) number of points generated
    :return Jaccard measure with 2 decimal digits
    """
    total_pairs = 0
    same_pairs = 0
    # Iterate over all pairs of points
    for i in range(n):
        for j in range(i, n):
            if initial_clusters[i] == initial_clusters[j] or clusters[i] == clusters[j]:
                total_pairs += 1
            if initial_clusters[i] == initial_clusters[j] and clusters[i] == clusters[j]:
                same_pairs += 1
    # Leave 2 decimal places
    return "%.2f" % (same_pairs / total_pairs)


def color_from_clusters(clusters, k):
    """
    Computes color of points on graphs for each cluster based on CMAP color scheme s.t. for every 2 points in the
    same cluster the same colors are given

    :param clusters (numpy.ndarray) clusters generated by one of the clustering algorithms
    :param k (int) number of clusters
    :return python list of colors of size k
    """
    cmap = plt.get_cmap(CMAP)
    norm = clr.Normalize(0, k)
    return [cmap(norm(i)) for i in clusters]


def draw_plot(points, n, k, spec_clusters, kmeans_clusters, init_clusters, d, K):
    """
    Draws 2 plots with points of dimension d with descriptive information and colors each cluster into different
    color based on color scheme. Dimension of the plots depends on d - if d==3 draws 3D plot, for d==2 2D plot

    :param K (int) number of centers generated originally
    :param points (numpy.ndarray) array of points to draw
    :param n (int) number of points
    :param k (int) number of clusters
    :param spec_clusters (numpy.ndarray) array of size k of clusters generated by spectral clustering
    :param kmeans_clusters (numpy.ndarray) array of size k of clusters generated by k-means
    :param init_clusters (numpy.ndarray) array of initially generated clusters
    :param d (int) dimension of each point (can only get values 2 or 3)
    """
    fig = plt.figure()
    if d == 3:
        # For 3D points
        ax1, ax2 = fig.add_subplot(121, projection="3d"), fig.add_subplot(122, projection="3d")
        points_tup = x, y, z = points.T
    else:
        ax1, ax2 = fig.add_subplot(121), fig.add_subplot(122)
        # For 2D points
        points_tup = x, y = points.T
    # Draw graphs and write descriptive information
    ax1.set_title("Normalized Spectral Clustering")
    ax2.set_title("K-means")
    ax1.scatter(*points_tup, c=color_from_clusters(spec_clusters, k), s=POINT_SIZE)
    ax2.scatter(*points_tup, c=color_from_clusters(kmeans_clusters, k), s=POINT_SIZE)
    plot_desc = "Data was generated from the values:\nn = " + str(n) + ", k = " + str(K) + "\n"
    plot_desc += "The k that was used for both algorithms was " + str(k) + "\n"
    plot_desc += "The Jaccard measure for Spectral Clustering: " + str(compute_jaccard_measure(init_clusters,
                                                                                               spec_clusters, n)) + "\n"
    plot_desc += "The Jaccard measure for K-means: " + str(compute_jaccard_measure(init_clusters, kmeans_clusters, n))
    plt.figtext(0.5, -0.1, plot_desc, ha="center")
    # Save plot into .pdf file
    fig.savefig(PLOT_PATH, bbox_inches="tight")
